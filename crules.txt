*GitHub Repository crules*

'''###--- CHANGELOG.md ---###
# Changelog

## [0.1.2] - 2023-11-18
### Added
- Improved help messages with detailed option descriptions
- Debug logging for rule file operations
- Better error handling with full tracebacks in verbose mode

### Changed
- Enhanced --force behavior with --setup to update existing rules
- Improved logging messages for file operations
- Updated CLI documentation

## [0.1.1] - 2023-11-18
### Added
- Version flag (--version, -V) to CLI
- PyPI support with proper package metadata
- PyPI badges in README
- Comprehensive release documentation

### Changed
- Updated default_cursorrules with CHANGELOG.md management
- Enhanced project metadata in pyproject.toml

## [0.1.0] - 2023-11-18
### Added
- Initial release
- Global and language-specific cursor rules management
- Setup command for first-time configuration
- Multiple language support
- Backup functionality
- YAML configuration 

'''

'''###--- README.md ---###
# Crules - Cursor Rules Generator

A Python utility for generating `.cursorrules` files by combining global and language-specific cursor rules.

## Features

- Combines global cursor rules with language-specific rules
- Supports multiple programming languages
- Automatic backup of existing rules
- List available language configurations
- Configurable via YAML configuration
- Verbose logging support

## Installation

1. Clone the repository:
```bash
git clone https://github.com/draeician/crules.git
cd crules
```

2. Install using pipx: (much better than doing pip install .)
```bash
pipx install .
```
NOTE:  uninstall with pipx uninstall crules or 

> **Note:** If you encounter an "externally-managed-environment" error, you have two options:
> 1. **Recommended:** Create and use a virtual environment:
>    ```bash
>    python3 -m venv .venv
>    source .venv/bin/activate  # On Windows: .venv\Scripts\activate
>    pip install .
>    ```us
> 2. **Alternative:** Use the `--break-system-packages` flag (not recommended):
>    ```bash
>    pip install . --break-system-packages
>    ```
>    This is not recommended as it may interfere with system Python packages.

## Configuration

The default configuration file is located at `~/.config/Cursor/cursor-rules/config.yaml`:

```yaml
global_rules_path: "~/.config/Cursor/cursor-rules/cursorrules"
language_rules_dir: "~/.config/Cursor/cursor-rules/lang_rules"
delimiter: "\n# --- Delimiter ---\n"
backup_existing: true
```

### Directory Structure

```
~/.config/Cursor/cursor-rules/
├── config.yaml
├── cursorrules
└── lang_rules/
    ├── cursor.python
    ├── cursor.javascript
    └── cursor.<language>
```

## Usage

### Basic Usage

Generate a `.cursorrules` file for one or more languages:

```bash
# Single language
python -m crules python

# Multiple languages
python -m crules python javascript rust
```

### List Available Languages

View all available language configurations:

```bash
python -m crules --list
```

Example output:
```
Available language rules:
- python (cursor.python)
- javascript (cursor.javascript)
- rust (cursor.rust)
```

### Additional Options

```bash
# Force overwrite existing .cursorrules file
python -m crules -f python

# Enable verbose output
python -m crules -v python

# Show help
python -m crules --help
```

## Command-line Options

- `languages`: One or more language identifiers
- `-f, --force`: Force overwrite of existing files
- `-v, --verbose`: Enable verbose output
- `-l, --list`: List available language rules
- `-s, --setup`: Create necessary directories and files
- `-h, --help`: Show help message

### First Time Setup

Before using crules, run the setup command to create necessary directories and files:

```bash
python -m crules --setup
```

This will create:
- Configuration directory: `~/.config/Cursor/cursor-rules/`
- Language rules directory: `~/.config/Cursor/cursor-rules/lang_rules/`
- Global rules file: `~/.config/Cursor/cursor-rules/cursorrules`
- Default config file: `~/.config/Cursor/cursor-rules/config.yaml`

## File Structure

The generated `.cursorrules` file combines:
1. Global rules from the `cursorrules` file
2. Language-specific rules from `cursor.<language>` files
3. Uses a configurable delimiter between sections

Example structure:
```
# Global Rules
<global rules content>

# --- Delimiter ---

# Rules for python
<python rules content>

# --- Delimiter ---

# Rules for javascript
<javascript rules content>
```

## Development

### Requirements

- Python 3.9+
- PyYAML
- Click

### Project Structure

```
crules/
├── src/
│   └── crules/
│       ├── __init__.py
│       ├── __main__.py
│       ├── cli.py
│       ├── config.py
│       └── file_ops.py
├── pyproject.toml
└── README.md
```

### Setting Up Development Environment

1. Clone the repository
2. Create a virtual environment:
```bash
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
```

3. Install development dependencies:
```bash
pip install -e ".[dev]"
```

## Contributing

1. Fork the repository
2. Create a feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

## License

This project is licensed under the MIT License - see the LICENSE file for details.

[![PyPI version](https://badge.fury.io/py/crules.svg)](https://badge.fury.io/py/crules)
[![Python versions](https://img.shields.io/pypi/pyversions/crules.svg)](https://pypi.org/project/crules/) 

'''

'''###--- requirements.txt ---###
# Core dependencies
pyyaml>=6.0.0
click>=8.0.0

# Development dependencies (optional)
pytest>=7.0.0
pytest-cov>=4.0.0
ruff>=0.1.0
black>=23.0.0
mypy>=1.0.0 
'''

'''###--- LICENSE ---###
MIT License

Copyright (c) 2023 draeician

Permission is hereby granted... 
'''

'''###--- project_spec.md ---###
Possible Adiditonal Functionality.

1.  **Logging and Verbose Output**:
    
    *   **Why**: Adding logging capabilities can help track the script's operations, which is useful for debugging and monitoring. A verbose mode (`--verbose` or `-v`) can provide detailed output during execution, aiding in troubleshooting if something goes wrong.
    *   **Functionality**: The script could log actions like file reads/writes, errors encountered, and significant decision points (e.g., user prompts, file overwrites).
2.  **Custom Configuration Options**:
    
    *   **Why**: Allowing users to specify custom paths for configuration files or output files increases the script's flexibility and usability in various environments.
    *   **Functionality**: Command-line arguments or a separate configuration file to set custom paths, delimiters, or other preferences.
3.  **Error Handling and Exceptions**:
    
    *   **Why**: Robust error handling ensures that the script fails gracefully and provides meaningful feedback, improving user experience.
    *   **Functionality**: Catching exceptions, validating inputs, and providing clear error messages when files are missing or permissions are insufficient.
4.  **Backup Existing Files**:
    
    *   **Why**: Preventing data loss is important. Creating a backup of the existing `.cursorrules` file before overwriting can safeguard against accidental overwrites.
    *   **Functionality**: Automatically rename the existing file to `.cursorrules.bak` before creating a new one.
5.  **Unit Testing**:
    
    *   **Why**: Including tests ensures that the script works as intended and makes future maintenance easier.
    *   **Functionality**: Writing test cases for key functions, especially for file operations and argument parsing.
6.  **Cross-platform Compatibility**:
    
    *   **Why**: Ensuring the script works on different operating systems (Linux, macOS, Windows) broadens its usability.
    *   **Functionality**: Avoiding OS-specific features and testing on multiple platforms.

* * *

**Project Specification for Cursor Rules Generator Script**

**Overview**

Develop a Python script that generates a `.cursorrules` file in the current project directory. The script combines configuration rules from a global `cursorrules` file and one or more language-specific `cursor.<language>` files, using a delimiter to separate them. The language types are provided as command-line arguments, and the script supports multiple languages at once.

**Key Features**

1.  **Configuration Loading**
    
    *   **Config File**: Load configuration settings from `~/.config/Cursor/cursor-rules/config.yaml` (or `config.toml` if preferred).
        *   **Decision**: Use YAML (`config.yaml`) for its readability and familiarity in configuration files.
    *   **Settings**:
        *   Paths to global `cursorrules` file and language-specific `cursor.<language>` files.
        *   Custom delimiter string (if needed).
2.  **Command-Line Interface**
    
    *   **Usage**: `python script.py [options] <language1> [<language2> ...]`
    *   **Options**:
        *   `-f`, `--force`: Force overwrite of existing `.cursorrules` without prompt.
        *   `-v`, `--verbose`: Enable verbose output.
        *   `-h`, `--help`: Display help message.
        *   `-l`, `--list`: List available language rules.
        *   `-s`, `--setup`: Create necessary directories and files if they don't exist.
3.  **File Operations**
    
    *   **File Detection**:
        *   Check for the existence of the global `cursorrules` file.
        *   Check for the existence of each specified `cursor.<language>` file.
        *   Check for the existence of `.gitignore` file.
    *   **Error Handling**:
        *   If any file is missing, display an informative error message and exit.
    *   **Overwrite Prompt**:
        *   If `.cursorrules` already exists in the current directory and `--force` is not used, prompt the user (`[y/N]`) before overwriting.
    *   **Backup Existing File**:
        *   Optionally (based on configuration), create a backup of the existing `.cursorrules` file before overwriting.
    *   **Git Integration**:
        *   If `.gitignore` exists in the current directory, ensure `.cursorrules` is added to it.
        *   Add `.cursorrules` under a "# Cursor specific" section header.
        *   Add entry on a new line if not already present.
        *   Maintain proper newline formatting in `.gitignore`.
4.  **File Content Assembly**
    
    *   **Delimiter**:
        *   Use a specified delimiter (from config or default) to separate content sections.
        *   Example delimiter: `\n# --- Delimiter ---\n`
    *   **Content Order**:
        *   Global `cursorrules` content on top.
        *   For each language specified:
            *   Include the content of `cursor.<language>` files.
            *   If multiple languages are specified, each is appended with the delimiter in between.
    *   **Language Prefixing** (Optional):
        *   Optionally prefix each language section with a comment or header indicating the language.
        *   Example: `# Rules for <language>`
5.  **Output**
    
    *   **File Creation**:
        *   Write the assembled content to `.cursorrules` in the current directory.
    *   **Success Message**:
        *   Display a message indicating successful creation (if not in silent mode).
6.  **Logging and Verbose Output**
    
    *   **Verbose Mode**:
        *   If `--verbose` is specified, print detailed information about each step.
    *   **Logging**:
        *   Log important actions and errors to a log file or standard output (depending on configuration).
7.  **Error Handling**
    
    *   **Missing Files**:
        *   Provide clear messages indicating which file is missing.
    *   **Permission Issues**:
        *   Inform the user if the script lacks permissions to read source files or write the output file.
    *   **Invalid Arguments**:
        *   Handle unexpected command-line arguments gracefully.
8.  **Multiple Language Support**
    
    *   **Processing Multiple Languages**:
        *   Accept multiple language arguments and process each accordingly.
    *   **Delimiter Usage**:
        *   Use the same delimiter between multiple language sections.
    *   **Inclusion of Rules**:
        *   For each language `<language>`, include the corresponding `cursor.<language>` file content, followed by the global rules if specified in the configuration.

**Implementation Details**

*   **Programming Language**: Python 3.x
*   **Dependencies**:
    *   Standard Python libraries (`os`, `sys`, `argparse`, `yaml` or `toml`, depending on the config file format).
*   **Configuration File Format**:
    *   **YAML (`config.yaml`)**
        
        ```yaml
        global_rules_path: "/path/to/cursorrules"
        language_rules_dir: "/path/to/language/rules"
        delimiter: "\n# --- Delimiter ---\n"
        backup_existing: true
        ```
        
*   **Directory Structure**:
    *   **Global Config**: `~/.config/Cursor/cursor-rules/config.yaml`
    *   **Global Rules File**: As specified in the config (`global_rules_path`)
    *   **Language Rules Files**: Located in `~/.config/Cursor/cursor-rules/lang_rules/cursor.<language>`
*   **Setup Feature**:
    *   Creates necessary directories if they don't exist:
        ```
        ~/.config/Cursor/cursor-rules/
        ~/.config/Cursor/cursor-rules/lang_rules/
        ```
    *   Creates default files if they don't exist:
        *   `~/.config/Cursor/cursor-rules/cursorrules` (empty file)
        *   `~/.config/Cursor/cursor-rules/config.yaml` (with default configuration)
    *   Provides verbose output during setup if requested
    *   Returns success/failure status
    *   Can be run multiple times safely (idempotent)

**User Interaction Examples**

*   **Basic Usage**:
    
    ```bash
    python script.py python
    ```
    
    *   Generates `.cursorrules` with global rules and Python-specific rules.
*   **Multiple Languages**:
    
    ```bash
    python script.py python javascript
    ```
    
    *   Includes both Python and JavaScript rules.
*   **Force Overwrite**:
    
    ```bash
    python script.py --force python
    ```
    
    *   Overwrites existing `.cursorrules` without prompt.
*   **Verbose Output**:
    
    ```bash
    python script.py --verbose python
    ```
    
    *   Displays detailed processing information.
*   **List Available Languages**:
    ```bash
    python script.py --list
    ```
    *   Shows all available language rule files in the lang_rules directory
    *   Example output:
    ```
    Available language rules:
    - python (cursor.python)
    - javascript (cursor.javascript)
    - rust (cursor.rust)
    ```
*   **Setup Directory Structure**:
    ```bash
    python script.py --setup
    ```
    *   Creates necessary directories and files
    *   Example output:
    ```
    Setting up crules directory structure...
    Created directory: ~/.config/Cursor/cursor-rules
    Created directory: ~/.config/Cursor/cursor-rules/lang_rules
    Created file: ~/.config/Cursor/cursor-rules/cursorrules
    Created file: ~/.config/Cursor/cursor-rules/config.yaml
    Setup complete!
    ```

**Testing and Validation**

*   **Unit Tests**:
    *   Test loading of configuration files.
    *   Test file existence checks.
    *   Test the overwrite prompt logic.
    *   Test content assembly with various numbers of languages.
*   **Integration Tests**:
    *   Simulate running the script in different scenarios (no existing `.cursorrules`, with existing file, missing source files).

**Documentation**

*   **Usage Guide**:
    *   Provide a README with instructions on how to install and use the script.
*   **Configuration Guide**:
    *   Explain the structure and options available in `config.yaml`.

**Error Messages and Handling**

*   **File Not Found**:
    *   `"Error: Global rules file not found at /path/to/cursorrules. Use --setup to create required directories."`
    *   `"Error: Language rules directory not found at /path/to/language/rules. Use --setup to create required directories."`
*   **Setup Messages**:
    *   `"Created directory: ~/.config/Cursor/cursor-rules"`
    *   `"Created directory: ~/.config/Cursor/cursor-rules/lang_rules"`
    *   `"Created file: ~/.config/Cursor/cursor-rules/cursorrules"`
    *   `"Created file: ~/.config/Cursor/cursor-rules/config.yaml"`
*   **Permission Denied**:
    *   `"Error: Permission denied when attempting to read '/path/to/cursorrules'."`
*   **Invalid Language Argument**:
    *   `"Error: No language specified. Please provide at least one language."`

**Assumptions and Decisions**

*   **YAML over TOML**: Chose YAML for its widespread use and readability in configuration files.
*   **Default Delimiter**: Defined in the configuration file but can be overridden if necessary.
*   **No Special Cases**: Since no special cases were provided, the script focuses on the core functionality.

**Future Enhancements**

*   **Custom Delimiter per Language**: Allow specifying different delimiters for different languages if needed.
*   **Graphical User Interface**: Develop a GUI for users who prefer not to use the command line.
*   **Plugin System**: Enable support for additional languages or rules through plugins or extensions.

* * *

'''

'''###--- pyproject.toml ---###
[project]
name = "crules"
version = "0.1.2"
description = "Cursor Rules Generator Script"
readme = "README.md"
requires-python = ">=3.9"
license = {text = "MIT"}
keywords = ["cursor", "ai", "rules", "development"]
authors = [
    {name = "draeician", email = "draeician@gmail.com"},
]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
]
dependencies = [
    "pyyaml>=6.0",
    "click>=8.0.0",
    "setuptools>=42.0.0",
]

[project.urls]
Homepage = "https://github.com/draeician/crules"
Repository = "https://github.com/draeician/crules.git"
Documentation = "https://github.com/draeician/crules#readme"

[project.scripts]
crules = "crules.cli:main"

[tool.setuptools]
package-dir = {"" = "src"}
packages = ["crules", "crules.rules"]

[tool.setuptools.package-data]
"crules.rules" = [
    "cursor.*",
    "default_cursorrules"
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.ruff]
line-length = 88
target-version = "py39" 

'''

'''###--- .cursor/rules/pipx-for-virtual-environment.mdc ---###
---
description:
globs:
---

# Your rule content

- You can @ files here
- You can use markdown but dont have to

'''

'''###--- bin/crules ---###
#!/bin/bash
VENV_PATH="$HOME/.local/share/crules/venv"

# Create venv if it doesn't exist
if [ ! -d "$VENV_PATH" ]; then
    python3 -m venv "$VENV_PATH"
    "$VENV_PATH/bin/pip" install crules
fi

# Run crules with venv python
exec "$VENV_PATH/bin/python" -m crules "$@" 
'''

'''###--- src/crules/config.py ---###
"""Configuration management for crules."""
from pathlib import Path
from typing import Dict, Any
import yaml
import logging

logger = logging.getLogger(__name__)

DEFAULT_CONFIG = {
    "global_rules_path": "~/.config/Cursor/cursor-rules/cursorrules",
    "language_rules_dir": "~/.config/Cursor/cursor-rules/lang_rules",
    "delimiter": "\n# --- Delimiter ---\n",
    "backup_existing": True,
}

def load_config() -> Dict[str, Any]:
    """Load configuration from YAML file or return defaults."""
    config_path = Path("~/.config/Cursor/cursor-rules/config.yaml").expanduser()
    
    try:
        if config_path.exists():
            with config_path.open() as f:
                config = yaml.safe_load(f)
                logger.debug(f"Loaded configuration from {config_path}")
                return {**DEFAULT_CONFIG, **(config or {})}
    except Exception as e:
        logger.warning(f"Error loading config file: {e}")
    
    logger.debug("Using default configuration")
    return DEFAULT_CONFIG 
'''

'''###--- src/crules/__main__.py ---###
"""Entry point for crules."""
from .cli import main

if __name__ == "__main__":
    main() 
'''

'''###--- src/crules/cli.py ---###
"""Command-line interface for crules."""
from pathlib import Path
import logging
import click
from . import __version__
from . import config, file_ops

logging.basicConfig(
    level=logging.INFO,
    format='%(levelname)s: %(message)s'
)
logger = logging.getLogger(__name__)

@click.command()
@click.version_option(version=__version__, prog_name='crules')
@click.argument('languages', nargs=-1, required=False)
@click.option('-f', '--force', is_flag=True, 
              help='Force overwrite existing files. With --setup, updates existing rule files.')
@click.option('-v', '--verbose', is_flag=True, 
              help='Enable verbose output with detailed logging')
@click.option('-l', '--list', 'show_list', is_flag=True, 
              help='List available language rules in the rules directory')
@click.option('-s', '--setup', 'setup_dirs', is_flag=True, 
              help='Create or update necessary directories and rule files')
def main(languages: tuple[str, ...], force: bool, verbose: bool, show_list: bool, setup_dirs: bool) -> None:
    """Generate .cursorrules file combining global and language-specific rules.

    Use --setup to initialize or update the rules directory structure.
    Use --force with --setup to update existing rule files.
    Use --list to see available language rules.
    Use --verbose for detailed operation logging.
    """
    if verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    try:
        # Handle --setup option
        if setup_dirs:
            logger.info("Setting up crules directory structure...")
            if file_ops.setup_directory_structure(verbose, force):
                logger.info("Setup complete!")
            else:
                raise click.ClickException("Setup failed")
            return

        # Load configuration
        cfg = config.load_config()
        global_rules = Path(cfg['global_rules_path']).expanduser()
        lang_rules_dir = Path(cfg['language_rules_dir']).expanduser()
        
        # Handle --list option
        if show_list:
            file_ops.list_available_languages(lang_rules_dir)
            return
            
        # Require languages argument if not listing or setting up
        if not languages:
            raise click.UsageError("Please specify at least one language or use --list to see available options")
        
        # Suggest setup if directories don't exist
        if not global_rules.exists() or not lang_rules_dir.exists():
            raise click.ClickException(
                "Required directories not found. Run 'crules --setup' to create them."
            )
            
        # Validate files exist
        if not file_ops.check_files_exist(global_rules, lang_rules_dir, languages):
            raise click.ClickException("Required files not found")
            
        # Handle existing files
        if not file_ops.backup_existing_rules(force):
            return
            
        # Combine rules
        content = file_ops.combine_rules(
            global_rules, 
            lang_rules_dir,
            languages,
            cfg['delimiter']
        )
        
        # Write output file
        output_file = Path(".cursorrules")
        output_file.write_text(content)
        logger.info(f"Successfully created {output_file}")
        
    except Exception as e:
        raise click.ClickException(str(e)) 
'''

'''###--- src/crules/file_ops.py ---###
"""File operations for crules."""
from pathlib import Path
from typing import List, Dict
import logging
import shutil
import yaml
from importlib import resources

logger = logging.getLogger(__name__)

def copy_predefined_rules(lang_rules_dir: Path, verbose: bool = False, force: bool = False) -> None:
    """Copy predefined language rules to the lang_rules directory."""
    try:
        # Get predefined rules using importlib.resources
        with resources.files('crules.rules') as rules_path:
            if not rules_path.is_dir():
                logger.warning("No predefined rules found in package")
                return
                
            if verbose:
                logger.debug(f"Looking for rules in: {rules_path}")
                
            # Copy each rule file found
            for rule_file in rules_path.glob('cursor.*'):
                try:
                    if verbose:
                        logger.debug(f"Processing rule file: {rule_file}")
                    with rule_file.open('r') as src:
                        dest_file = lang_rules_dir / rule_file.name
                        if verbose:
                            logger.debug(f"Destination file: {dest_file} (exists: {dest_file.exists()}, force: {force})")
                        # Always copy if force is True or file doesn't exist
                        if force or not dest_file.exists():
                            content = src.read()
                            dest_file.write_text(content)
                            if verbose:
                                logger.info(f"{'Updated' if dest_file.exists() else 'Copied'} rules: {rule_file.name}")
                                logger.debug(f"Content length: {len(content)} bytes")
                        elif verbose:
                            logger.info(f"Skipped existing rules: {rule_file.name}")
                except Exception as e:
                    logger.error(f"Failed to copy {rule_file.name}: {e}")
                    raise  # Re-raise to see full traceback in verbose mode
                    
    except Exception as e:
        logger.error(f"Failed to copy predefined rules: {e}")
        raise  # Re-raise to see full traceback in verbose mode

def setup_directory_structure(verbose: bool = False, force: bool = False) -> bool:
    """Create necessary directories and files for crules.
    
    Args:
        verbose: Whether to show verbose output
        force: Whether to overwrite existing files
    """
    try:
        base_dir = Path("~/.config/Cursor/cursor-rules").expanduser()
        lang_rules_dir = base_dir / "lang_rules"
        config_file = base_dir / "config.yaml"
        global_rules = base_dir / "cursorrules"

        # Create directories
        base_dir.mkdir(parents=True, exist_ok=True)
        if verbose:
            logger.info(f"Created directory: {base_dir}")
        
        lang_rules_dir.mkdir(exist_ok=True)
        if verbose:
            logger.info(f"Created directory: {lang_rules_dir}")

        # Copy predefined language rules
        copy_predefined_rules(lang_rules_dir, verbose, force)

        # Create or update global rules file
        if not global_rules.exists() or force:
            try:
                with resources.files('crules.rules').joinpath('default_cursorrules').open('r') as src:
                    global_rules.write_text(src.read())
                    if verbose:
                        logger.info(f"{'Updated' if global_rules.exists() else 'Created'} file with default rules: {global_rules}")
            except Exception as e:
                logger.error(f"Failed to copy default rules: {e}")
                logger.warning("Creating empty file instead")
                global_rules.touch()
                if verbose:
                    logger.info(f"Created empty file: {global_rules}")

        # Create or update default config
        if not config_file.exists() or force:
            default_config = {
                "global_rules_path": str(global_rules),
                "language_rules_dir": str(lang_rules_dir),
                "delimiter": "\n# --- Delimiter ---\n",
                "backup_existing": True,
            }
            with config_file.open('w') as f:
                yaml.dump(default_config, f, default_flow_style=False)
            if verbose:
                logger.info(f"{'Updated' if config_file.exists() else 'Created'} file: {config_file}")

        return True
    except Exception as e:
        logger.error(f"Setup failed: {e}")
        return False

def get_available_languages(language_rules_dir: Path) -> Dict[str, Path]:
    """Get all available language rule files."""
    lang_rules = {}
    if not language_rules_dir.exists():
        return lang_rules
        
    for file in language_rules_dir.glob("cursor.*"):
        if file.is_file():
            lang = file.name.replace("cursor.", "")
            lang_rules[lang] = file
            
    return lang_rules

def list_available_languages(language_rules_dir: Path) -> None:
    """Display all available language rule files."""
    lang_rules = get_available_languages(language_rules_dir)
    
    if not lang_rules:
        logger.info("No language rules found.")
        return
        
    print("\nAvailable language rules:")
    for lang, file in sorted(lang_rules.items()):
        print(f"- {lang} ({file.name})")
    print()

def check_files_exist(global_rules: Path, language_rules_dir: Path, languages: List[str]) -> bool:
    """Check if all required files exist."""
    if not global_rules.exists():
        logger.error(f"Global rules file not found at {global_rules}")
        return False
    
    for lang in languages:
        lang_file = language_rules_dir / f"cursor.{lang}"
        if not lang_file.exists():
            logger.error(f"Language rules file not found at {lang_file}")
            return False
    
    return True

def backup_existing_rules(force: bool = False) -> bool:
    """Backup existing .cursorrules file if it exists."""
    rules_file = Path(".cursorrules")
    if not rules_file.exists():
        return True
        
    if not force:
        response = input("Existing .cursorrules found. Overwrite? [y/N] ").lower()
        if response != 'y':
            logger.info("Operation cancelled by user")
            return False
    
    try:
        backup_file = Path(".cursorrules.bak")
        shutil.copy2(rules_file, backup_file)
        logger.info(f"Backed up existing rules to {backup_file}")
        return True
    except Exception as e:
        logger.error(f"Failed to create backup: {e}")
        return False

def combine_rules(global_rules: Path, language_rules_dir: Path, 
                 languages: List[str], delimiter: str) -> str:
    """Combine global and language-specific rules."""
    content_parts = []
    
    # Add global rules
    try:
        content_parts.append(global_rules.read_text().strip())
    except Exception as e:
        logger.error(f"Failed to read global rules: {e}")
        raise
        
    # Add language-specific rules
    for lang in languages:
        try:
            lang_file = language_rules_dir / f"cursor.{lang}"
            # Add just the language header and content
            content = lang_file.read_text().strip()
            # Remove any existing language headers or delimiters
            content = content.replace("# --- Delimiter ---", "")
            content = '\n'.join(line for line in content.splitlines() 
                              if not line.strip().startswith("# Rules for"))
            content_parts.append(f"# Rules for {lang}\n{content}")
        except Exception as e:
            logger.error(f"Failed to read rules for {lang}: {e}")
            raise
    
    # Update .gitignore if it exists
    update_gitignore()
            
    return delimiter.join(content_parts)

def update_gitignore() -> None:
    """Add .cursorrules and .cursorrules.bak to .gitignore if it exists."""
    gitignore_path = Path('.gitignore')
    if not gitignore_path.exists():
        return

    # Read current content
    content = gitignore_path.read_text()
    lines = content.splitlines()

    # Check if either file is already in .gitignore
    cursor_entries = {'.cursorrules', '.cursorrules.bak'}
    existing_entries = cursor_entries.intersection(lines)
    
    if len(existing_entries) < len(cursor_entries):
        # Add section header and entries
        with gitignore_path.open('a') as f:
            # Ensure there's a newline before our new section if file isn't empty
            if content and not content.endswith('\n'):
                f.write('\n')
            f.write('\n# Cursor specific\n')
            
            # Add any missing entries
            for entry in cursor_entries - existing_entries:
                f.write(f'{entry}\n')
            
            logger.debug("Added Cursor entries to .gitignore")
'''

'''###--- src/crules/__init__.py ---###
"""Cursor Rules Generator Script."""

__version__ = "0.1.2" 
'''

'''###--- src/crules/rules/cursor.javascript ---###
You are an AI assistant specialized in JavaScript development. Follow these guidelines:

1. Use ES6+ features and syntax.
2. Follow Airbnb JavaScript Style Guide.
3. Use camelCase for variable and function names, and PascalCase for class names.
4. Prefer const for variable declarations, use let only when necessary.
5. Use arrow functions for short, non-method functions.
6. Use template literals for string interpolation.
7. Use destructuring assignment where applicable.
8. Implement proper error handling with try-catch blocks.
9. Use async/await for asynchronous operations instead of callbacks.
10. Write JSDoc comments for functions and classes.
11. Use modules (import/export) for code organization.
12. Prefer map, filter, and reduce for array operations.

'''

'''###--- src/crules/rules/cursorrules ---###
Important files and what they are will be used for:
project_spec.md

SOP List to apply to any project:
- Reference the project_spec.md file when giving instructions to Composer.  If the project_spec.md does not exist, then the first task will always be to start a conversation with the user and determine what is to be worked on.
- Each time user asks you a query, write every user prompt that you receive to instructions.txt each one seperated by a new line and --- between the prompt.  You have to do this each time regardless of the type of prompt.  create the file if it doesn't exist.  do this along with other files you are creating or modifying.
- Each time user asks you a query, write a running and evolving bullet point summaryh of the project to summary.txt.  You have to do this each time regardless of the type of prompt. create the file if it doesn't exist.  do this along with other files you are creating or modifying.  feel free to just update it rather than writing over it each time.
- Adhere strictly to our team's code style guide
- Emphasize functional programming
- Ensure comments explain the "why," not the "how"

# Dataflow
Use a combination of **flowchart diagrams**, **class diagrams**, **state diagrams**, and **context diagrams** to represent data flow in complex systems. When analyzing a code base, follow these steps to determine which diagrams are most suitable, and how to organize and link them effectively:
### Context Diagrams
- **Context diagrams** provide a high-level view of the system, showing interactions with external entities. Use these to understand how the code base interacts with external systems or users.
- This should be the entry point diagram that links to other more detailed diagrams.
### Flowchart Diagrams
- **Flowchart diagrams** illustrate the flow of information between components, mapping actions and data flow between agents, tools, or databases.
- Represent each component as a node, using arrows to show data flow.
- Create separate flowchart diagrams for each specific module or process, and reference them from the context diagram.
### Class Diagrams
- **Class diagrams** describe hierarchical relationships and roles of components, showcasing organization and shared attributes.
- Use these diagrams when analyzing the object-oriented structure of the codebase.
- Cross-reference relevant flowcharts and context diagrams for better linkage.
### State Diagrams
- **State diagrams** represent transitions or state changes in a system, illustrating how agents change roles or contexts with new data.
- Use these diagrams to capture significant state transitions present in the code logic.
- Include notes to indicate which processes or classes these state diagrams relate to.
### Detailed Functional Breakdown
- For more detailed analysis, use **Level 0 or Level 1 data flow diagrams** to illustrate data flow within individual processes or modules of the codebase.
- Link these to higher-level diagrams for better traceability.
### General Guidance
- Store each diagram in a **diagrams directory** or **dataflow directory**, using a consistent naming convention (e.g., "Context_Diagram", "Flowchart_ModuleA", "ClassDiagram_ModuleB") to make relationships clear.
- Maintain an **overview index** file that explains the relationships between diagrams and acts as a guide to navigate through them.
- Label each node to indicate its function, and use arrows to show interactions.
- Use context diagrams for system boundaries, flowcharts for process flow, class diagrams for structure, and state diagrams for dynamic changes.
- Include cross-references in each diagram (e.g., "See Flowchart_ModuleA for more details on Process X").

## Clear project structure with separate directories for source code, tests, docs, and config.
## Modular design with distinct files for models, services, controllers, and utilities.
## Configuration management using environment variables.4. Robust error handling and logging, including context capture.
## Comprehensive testing with pytest.
## Detailed documentation using docstrings and README files.
## Dependency management via https://github.com/astral-sh/rye and virtual environments.
## Code style consistency using Ruff.
## CI/CD implementation with GitHub Actions or GitLab CI.
## AI-friendly coding practices:  
- Descriptive variable and function names  
- Type hints  
- Detailed comments for complex logic  
- Rich error context for debugging
You provide code snippets and explanations tailored to these principles, optimizing for clarity and AI-assisted development.

When asked to generate a commit message, follow these guidelines:
1. Use the conventional commits format: <type>[optional scope]: <description>
2. Keep the first line under 50 characters
3. Use imperative mood in the subject line
4. Provide a more detailed explanation in the body if necessary
5. Reference relevant issue numbers if applicable

Reference URLS:
https://github.com/ollama/ollama/blob/main/docs/api.md
https://github.com/ollama/ollama/blob/main/docs/modelfile.md


'''

'''###--- src/crules/rules/cursor.java ---###
You are an AI assistant specialized in Java development. Follow these guidelines:

1. Follow Google Java Style Guide.
2. Use camelCase for method and variable names, PascalCase for class names.
3. Declare variables as final whenever possible.
4. Use interfaces for abstraction.
5. Implement proper exception handling with try-catch blocks.
6. Use Java 8+ features like lambdas and streams where appropriate.
7. Write Javadoc comments for public methods and classes.
8. Follow the SOLID principles in object-oriented design.
9. Use StringBuilder for string concatenation in loops.
10. Prefer composition over inheritance.
11. Use dependency injection for managing object dependencies.
12. Implement proper resource management with try-with-resources.

'''

'''###--- src/crules/rules/cursor.perl ---###
You are an AI assistant specialized in Perl development. Follow these guidelines:

1. Adhere to Perl Best Practices as outlined by Damian Conway.
2. Use strict and warnings pragmas in all scripts.
3. Prefer open-source CPAN modules over proprietary solutions.
4. Use meaningful variable names in lower_snake_case.
5. Use PascalCase for package names.
6. Write subroutine names in lower_snake_case.
7. Use parentheses for function calls to improve readability.
8. Implement proper error handling using eval blocks and $@ variable.
9. Use the three-argument form of open() for file operations.
10. Prefer foreach over for loops when iterating over arrays.
11. Use Perl's built-in functions and operators when possible.
12. Write documentation using POD (Plain Old Documentation) format.
13. Use Perl::Critic for static code analysis.
14. Implement unit tests using Test::More or similar testing frameworks.
15. Prefer object-oriented programming using Moose or Moo for complex projects.

'''

'''###--- src/crules/rules/cursor.lua ---###
You are an AI assistant specialized in Lua development. Follow these guidelines:

1. Adhere to the Lua Style Guide by Olivine Labs.
2. Use camelCase for variable and function names.
3. Use PascalCase for module names and metatables.
4. Prefer local variables over global variables.
5. Use meaningful and descriptive names for variables and functions.
6. Implement proper error handling using pcall or xpcall.
7. Use Lua's built-in functions and standard libraries when possible.
8. Prefer open-source Lua libraries and frameworks (e.g., LÖVE for game development).
9. Write comments to explain complex logic or non-obvious code.
10. Use luarocks for managing external dependencies.
11. Implement unit tests using Busted or a similar testing framework.
12. Use LuaCheck for static code analysis.
13. Prefer ipairs() for array-like tables and pairs() for hash-like tables.
14. Use the module() function or return table pattern for creating modules.
15. Implement proper memory management, especially when dealing with large datasets.
16. Use metatables and metamethods for object-oriented programming when appropriate.
17. Leverage Lua's coroutines for cooperative multitasking when needed.

'''

'''###--- src/crules/rules/cursor.python ---###
You are an AI assistant specialized in Python development. Follow these guidelines:

1. Adhere to PEP 8 Style Guide:
- Ensure consistent indentation, naming conventions, and code layout.
- Limit lines to 79 characters for code and 72 for docstrings.
2. Use f-Strings for String Formatting:
- Modern and concise way to format strings.
- Example: f"The answer is {x}"
3. Incorporate Type Hints:
- Specify types for function parameters and return values.
- Example: def add(a: int, b: int) -> int:
4. Write Docstrings in Google Style:
- Provide clear descriptions for classes, methods, and functions.
- Include parameters, return values, and exceptions if any.
5. Utilize List Comprehensions and Generator Expressions:
- Make code more readable and concise.
- Use generators for memory-efficient iteration.
6. Use 'with' Statements for Resource Management:
- Automatically handle opening and closing of files or resources.
- Example: with open('file.txt') as f:
7. Set Up Virtual Environments:
- Isolate project dependencies.
- Use pipx to create virtual environments.
8. Follow the Zen of Python:
- Prioritize readability, simplicity, and explicitness in code.
9. Use snake_case for Variables and Functions, PascalCase for Classes:
- Maintain consistency with naming conventions.
10. Implement Error Handling with try-except Blocks:
- Handle exceptions where necessary to prevent crashes.
- Avoid broad exceptions; be specific.
11. Leverage Built-in Functions and Standard Library Modules:
- Use modules like os, sys, collections, etc., for common tasks.
12. Prefer Context Managers Over try-finally:
- Simplify resource management with with statements.
13. Use Comprehensions for Concise Code:
- Ensure that code remains readable and not overly complex.
14. Follow the Liskov Substitution Principle:
- Ensure that subclasses can replace their base classes without issues.
15. Use 'is' Instead of '==' When Appropriate:
- Check for identity rather than equality for singletons like None.
16. Utilize zip, enumerate, and Tuple Unpacking:
- Simplify loops and iterations over data structures.
17. Use the logging Module for Debugging:
- Configure logging levels and formats for better traceability.
18. Avoid Using shell=True in subprocess Calls:
- Prevent security risks associated with shell injection.
19. Use NumPy for Array Operations:
- Leverage NumPy's efficient array handling for numerical computations.
20. Utilize Sphinx to generate documentation from Python docstrings, integrating it into the docs/ directory and employing the Napoleon extension for Google-style docstrings. Automate documentation builds with a CI/CD pipeline.
21. Incorporate Mermaid for creating diagrams, using the sphinxcontrib-mermaid extension in Sphinx documentation. Ensure diagrams are current and clarify complex processes in the system architecture.

Project structure should be setup as follows:
my_project/
├── README.md
├── LICENSE
├── requirements.txt
├── setup.cfg
├── pyproject.toml
├── .gitignore
├── .pre-commit-config.yaml
├── src/
│   └── my_package/
│       ├── __init__.py
│       ├── module1.py
│       ├── module2.py
│       └── subpackage/
│           ├── __init__.py
│           └── submodule.py
├── tests/
│   └── test_module1.py
│   └── test_module2.py
├── docs/
│   └── conf.py
│   └── index.rst
└── scripts/
    └── run_script.py

Explanation of Project Structure
README.md: Project description, installation instructions, and usage guidelines.
LICENSE: License file defining the terms of use for the project.
requirements.txt: Lists project dependencies for reproducibility.
setup.cfg and pyproject.toml: Configuration files for setuptools and build system.
.gitignore: Specifies files and directories to be ignored by Git.
.pre-commit-config.yaml: Configuration for pre-commit hooks to enforce code quality.
src/: Contains the source code organized into packages and modules.
my_package/: The main package with submodules and subpackages.
tests/: Holds unit tests for the codebase.
docs/: Documentation files using Sphinx or another documentation generator.
scripts/: Scripts for running the application or other tasks.



'''

'''###--- src/crules/rules/cursor.bash ---###
You are an AI assistant specialized in Bash scripting. Follow these guidelines:

1. Begin scripts with #!/bin/bash shebang.
2. Use shellcheck for static analysis of shell scripts.
3. Follow Google's Shell Style Guide.
4. Use lowercase for variable names and uppercase for environment variables.
5. Quote variables to prevent word splitting and globbing.
6. Use [[ ]] for conditional tests instead of [ ].
7. Use $(command) instead of backticks for command substitution.
8. Implement error handling using set -e and trap commands.
9. Use meaningful function and variable names.
10. Add comments to explain complex logic or non-obvious code.
11. Use local variables within functions to avoid global namespace pollution.
12. Prefer built-in commands over external programs for better performance.
13. Use parameter expansion for string manipulation when possible.
14. Implement proper exit codes (0 for success, non-zero for errors).
15. Use getopts for parsing command-line arguments.
16. Prefer open-source tools and utilities available in standard Linux distributions.

'''

'''###--- src/crules/rules/default_cursorrules ---###
# Cursor Rules

Please do not run any terminal commands to run files.
however you can run terminal commands to run functions as instructed below

you have tools as functions you can use in the tools.py file

current tools are:
- web search (use this anytime you need any additional information)

you are not allowed to create .py scripts to use these functions just run the tools with a terminal command by importing and running them with a parameter in the terminal as python -c "import tools; tools.function_name(parameter)"

EXAMPLE:


## Important Files and Their Use:
- **project_spec.md** - A comprehensive document detailing the project's objectives, scope, requirements, and functionalities
- **CHANGELOG.md** - Records all version changes and updates
- **ainotes.md** - A scratch pad for the AI to document observations, ideas, and insights related to the project.

## SOP List to apply to any project:
  - Reference the project_spec.md file when giving instructions to Composer. If the project_spec.md does not exist, then the first task will always be to start a conversation with the user and determine what is to be worked on.
  - Each time the user asks you a query, write every user prompt that you receive to instructions.txt, each one separated by a new line and "---" between the prompts. You have to do this each time regardless of the type of prompt. Create the file if it doesn't exist. Do this along with other files you are creating or modifying.
  - Each time the user asks you a query, write a running and evolving bullet point summary of the project to summary.txt. You have to do this each time regardless of the type of prompt. Create the file if it doesn't exist. Do this along with other files you are creating or modifying. Feel free to just update it rather than writing over it each time.
  - When preparing a new release:
    1. Update CHANGELOG.md with the new version section
    2. Follow the format:
       ```markdown
       ## [VERSION] - YYYY-MM-DD
       ### Added
       - New features
       
       ### Changed
       - Modified features
       
       ### Fixed
       - Bug fixes
       
       ### Deprecated
       - Soon-to-be removed features
       
       ### Removed
       - Removed features
       ```
    3. List all significant changes since the last version
    4. Keep entries clear and concise
    5. Use present tense for change descriptions

## Dataflow Diagrams:
Use a combination of **flowchart diagrams**, **class diagrams**, **state diagrams**, and **context diagrams** to represent data flow in complex systems. When analyzing a code base, follow these steps to determine which diagrams are most suitable, and how to organize and link them effectively:

### Context Diagrams
- **Context diagrams** provide a high-level view of the system, showing interactions with external entities. Use these to understand how the code base interacts with external systems or users.  
  This should be the entry point diagram that links to other more detailed diagrams.

### Flowchart Diagrams
- **Flowchart diagrams** illustrate the flow of information between components, mapping actions and data flow between agents, tools, or databases.  
  Represent each component as a node, using arrows to show data flow.  
  Create separate flowchart diagrams for each specific module or process, and reference them from the context diagram.

### Class Diagrams
- **Class diagrams** describe hierarchical relationships and roles of components, showcasing organization and shared attributes.  
  Use these diagrams when analyzing the object-oriented structure of the codebase.  
  Cross-reference relevant flowcharts and context diagrams for better linkage.

### State Diagrams
- **State diagrams** represent transitions or state changes in a system, illustrating how agents change roles or contexts with new data.  
  Use these diagrams to capture significant state transitions present in the code logic.  
  Include notes to indicate which processes or classes these state diagrams relate to.

### Detailed Functional Breakdown
- For more detailed analysis, use **Level 0 or Level 1 data flow diagrams** to illustrate data flow within individual processes or modules of the codebase.  
  Link these to higher-level diagrams for better traceability.

### General Guidance
- Store each diagram in a **diagrams directory** or **dataflow directory**, using a consistent naming convention (e.g., "Context_Diagram", "Flowchart_ModuleA", "ClassDiagram_ModuleB") to make relationships clear.
- Maintain an **overview index** file that explains the relationships between diagrams and acts as a guide to navigate through them.
- Label each node to indicate its function, and use arrows to show interactions.
- Use context diagrams for system boundaries, flowcharts for process flow, class diagrams for structure, and state diagrams for dynamic changes.
- Include cross-references in each diagram (e.g., "See Flowchart_ModuleA for more details on Process X").

## Project Structure and Best Practices:
- Clear project structure with separate directories for source code, tests, docs, and config.
- Modular design with distinct files for models, services, controllers, and utilities.
- Configuration management using environment variables.
- Robust error handling and logging, including context capture.
- Comprehensive testing with pytest.
- Detailed documentation using docstrings and README files.
- Dependency management via virtual environments.
- Code style consistency using Ruff.
- CI/CD implementation with GitHub Actions or GitLab CI.
- AI-friendly coding practices:
  - Descriptive variable and function names.
  - Type hints.
  - Detailed comments for complex logic.
  - Rich error context for debugging.

### Commit Message Guidelines:
1. Use the conventional commits format: `<type>[optional scope]: <description>`
2. Keep the first line under 50 characters.
3. Use imperative mood in the subject line.
4. Provide a more detailed explanation in the body if necessary.
5. Reference relevant issue numbers if applicable.

## Global Cursor Rules
These rules apply to all languages:

1. Follow consistent code formatting and style guidelines.
2. Write clear and descriptive variable and function names.
3. Include appropriate comments and documentation.
4. Handle errors and edge cases appropriately.
5. Write modular and reusable code.
6. Follow version control best practices.
7. Implement proper testing.
8. Consider performance implications.
9. Maintain security best practices.
10. Keep code DRY (Don't Repeat Yourself).

'''

'''###--- src/crules/rules/__init__.py ---###
"""Package containing predefined language rules.""" 
'''
